identical(as.data.frame(BSR$q0.025)[[1]] %>% as.integer() %>% as.numeric(), as.data.frame(BSR$q0.5) %>% as.integer() %>% as.numeric())
identical(as.data.frame(BSR$q0.025)[[1]] %>% as.integer() %>% as.numeric(), as.data.frame(BSR$q0.5)[[1]] %>% as.integer() %>% as.numeric())
as.data.frame(BSR$q0.5)[[1]] %>% as.integer() %>% as.numeric()
supfam  <- "all"
file_name <- paste(supfam, ens_alg, projt, sep = "_")
print(file_name)
sp <- popaPlot(
projRasters         = mae,
type                = "presence_absence",
superfamily         = supfam,
ensemble_algorithm  = ens_alg,
projection_time     = projt,
threshold_algorithm = "TSS",
do_plot             = FALSE,
do_plot_combine     = FALSE
)
sp_pa <- sp$species
# Sélection des profondeurs 0-150m
sp_pa <- sp_pa * dmask
sp_cb <- sp$combine * dmask
# bootstrap
print("Bootsrap")
bootstrap <- lapply(
seq(1, n_resamp),
\(x) {
sample(
x       = names(sp_pa),
size    = length(names(sp_pa)),
replace = TRUE
)
})
print("Bootsrap ok")
# Sélection des noms uniques d'espèces
print("Selection des noms d'espèces")
bootstrap <- bootstrap %>%
lapply(\(nsp) unique(nsp))
print("Selection des noms d'espèces ok")
# Création de raster sommes de toutes les présences/absences des
# espèces selon le jeu d'espèces issu du bootstrap
print("Aggrégation du raster")
t0 <- Sys.time()
bootstrap_raster <- mclapply(
1:length(bootstrap),
\(i) {
# i <- 1
parPrint(paste0(i, "/", length(bootstrap)))
nsp    <- bootstrap[[i]]
sr_sub <- subset(sp_pa, nsp)
return(wrap(sum(sr_sub, na.rm = TRUE)))
},
mc.cores = detectCores() - 1
) %>% lapply(unwrap)
t1 <- Sys.time()
print(t1-t0)
print("Aggrégation du raster ok")
print("Changement des noms du raster")
bootstrap_raster <- Mapply(
\(r, id) {names(r) <- paste0("run", id) ; return(r)},
bootstrap_raster,
1:n_resamp
)
print("Changement des noms du raster ok")
print("Aggrégation des rasters")
bsr <- do.call(c, bootstrap_raster)
print("Aggrégation des rasters ok")
# sauvegarde du raster de tous les runs de ré-échantillonnage
# print("Sauvegarde")
# writeRaster(
#   bsr,
#   here(pout, paste0("bootstrap_sr_", file_name, ".tif")),
#   overwrite = T
# )
# print("Sauvegarde ok")
# Calcul de trois estimateurs de richesse spécifique
# aggrégation aux données initiales
print("Raster des quantiles")
bsr_chunks <- fragSpatialRaster(bsr, dvd = 100)
bsr_chunks_quant <- mclapply(
bsr_chunks,
\(chnk) {
quantile(
chnk, probs = c(0.025, 0.500, 0.975), na.rm = TRUE
)
},
mc.cores = 1
)
bsr_quant <- Reduce(merge, bsr_chunks_quant)
print("Raster des quantiles ok")
BSR <- c(sp$combine, bsr_quant)
names(BSR)[1] <- "init"
plot(BSR)
source("~/Documents/mosceco/r_projects/MOSCECO_L3/spatial_planification/scripts/boot.R", echo=TRUE)
source("~/Documents/mosceco/r_projects/MOSCECO_L3/spatial_planification/scripts/sensibility_index.R", echo=TRUE)
nisl     <- "GLP"
projt    <- "current"
supfam   <- "all"
subfam   <- switch(supfam, all = "ALL", Majoidea = "MAJ", Muricoidea = "MUR")
scenario <- "opti" # "pessi"
status   <- "none"
# 2. Sous-échantillons ####
my_subsets <- list(
ALL = c(
"Amphithrax hemphilli",
"Macrocoeloma nodipes",
"Mithraculus coryphe",
"Mithraculus forceps",
"Mithrax pleuracanthus",
"Omalacantha bicornuta",
"Stenorhynchus seticornis",
"Teleophrys ruber",
"Claremontiella nodulosa",
"Coralliophila galea",
"Coralliophila salebrosa",
"Favartia alveata",
"Favartia varimutabilis",
"Phyllonotus pomum",
"Siratus consuelae",
"Stramonita rustica",
"Trachypollia didyma",
"Vasula deltoidea",
NULL
) %>% sort(),
MAJ = c(
"Amphithrax hemphilli",
"Macrocoeloma nodipes",
"Mithraculus coryphe",
"Mithraculus forceps",
"Mithrax pleuracanthus",
"Omalacantha bicornuta",
"Stenorhynchus seticornis",
"Teleophrys ruber",
NULL
),
MUR = c(
"Claremontiella nodulosa",
"Coralliophila galea",
"Coralliophila salebrosa",
"Favartia alveata",
"Favartia varimutabilis",
"Phyllonotus pomum",
"Siratus consuelae",
"Stramonita rustica",
"Trachypollia didyma",
"Vasula deltoidea",
NULL
) %>% sort()
)
my_subsets <- my_subsets[subfam]
# 3. Choix des quantité d'unités de conservation à préserver ####
target <- c(
"Amphithrax hemphilli",
"Macrocoeloma nodipes",
"Mithraculus coryphe",
"Mithraculus forceps",
"Mithrax pleuracanthus",
"Omalacantha bicornuta",
"Stenorhynchus seticornis",
"Teleophrys ruber",
"Claremontiella nodulosa",
"Coralliophila galea",
"Coralliophila salebrosa",
"Favartia alveata",
"Favartia varimutabilis",
"Phyllonotus pomum",
"Siratus consuelae",
"Stramonita rustica",
"Trachypollia didyma",
"Vasula deltoidea",
NULL
) %>%
sort()
# Ou quantités identiques pour toutes les espèces
# À mettre en commentaire si des espèces sont sélectionnées dans
# la liste ci-dessus.
target <- 1
# Proportion des cellules des espèces à conserver
# target_prop <- rep(0.85, length(target))
# 4. Choix des pénalités pour la non-présence des espèces dans ####
# la réserve finale
spf <- c(
"Amphithrax hemphilli",
"Macrocoeloma nodipes",
"Mithraculus coryphe",
"Mithraculus forceps",
"Mithrax pleuracanthus",
"Omalacantha bicornuta",
"Stenorhynchus seticornis",
"Teleophrys ruber",
"Claremontiella nodulosa",
"Coralliophila galea",
"Coralliophila salebrosa",
"Favartia alveata",
"Favartia varimutabilis",
"Phyllonotus pomum",
"Siratus consuelae",
"Stramonita rustica",
"Trachypollia didyma",
"Vasula deltoidea",
NULL
)
# Ou quantités identiques pour toutes les espèces
# À mettre en commentaire si des espèces sont sélectionnées dans
# la liste ci-dessus.
spf <- 1000
# Choix des coûts de mailles à partir :
# - De rien, modèle "nul"
spatRast_cost_list <- NULL
spatRast_cost_list <- list(
# - De la qualité de hotspot de diversité
# Objectif : Plus une zone ré-échantillonnée est riche en espèce, plus il est
# couteux de ne pas l'inclure dans la réserve.
# Concrètement, j'augmente le coût de chaque unité de planification
# proportionnellement à sa richesse spécifique.
hotspot = rl$current$q0.5,
# - De la variation de richesses spécifiques
# Coefficient de variation
# Plus une zone perd des espèces (coefficient de variation qui tend vers -1)
# plus elle est sensible aux changements climatiques à venir et plus il est
# nécessaire de la conserver, donc plus le coût de l'écartement de cette
# maille dans la réserve est élevé.
percvar = rv[[scenario]]$q0.5/2 + 0.5,
# - De la diversité beta temporelle
betadiv = rb[[scenario]]$beta.sor,
NULL
)
# - De la variation de richesses spécifiques (pourcentage de variation > 0.5)
# cost_threshold <- 0.85
# Choix du nombre de répétitions du modèle ####
# repetitions <- "auto"
repetitions <- 100
# emprise spatiale
e <- ext_marxan[[nisl]]
# species
sp <- popaPlot(
projRasters        = mae,
type               = "presence_absence",
superfamily        = supfam,
ensemble_algorithm = "wmean",
projection_time    = projt,
do_plot            = FALSE,
do_plot_combine    = FALSE
)
sp_pa <- sp$species %>% terra::crop(e)
# Sélection des profondeurs 0-150m
dmask <- climosaic$depth %>% terra::crop(e)
dmask <- ifel(dmask > -150, 1, NA)
sp_pa <- sp_pa * dmask
# classification
cl <- read.csv(here("data", "tidy", "classification.csv"))
cl$Species <- cl$Species %>%
gsub(" ", "_", .)
cl$SpeciesID <- 1:nrow(cl)
print(
paste(
"Le jeu de données biologique initial contient",
length(names(sp_pa)),
"espèces."
)
)
# Sous-ensemble de données
sp_subs <- sapply(
my_subsets,
\(my_sub) terra::subset(sp_pa, my_sub),
USE.NAMES = T,
simplify = F
)
# Noms des espèces dans les sous-ensembles
sp_names <- my_subsets
# Carte de richesse spécifique
sp_sr <- sapply(
sp_subs,
\(r) terra::app(r, sum),
USE.NAMES = T
)
# Nombre de répétitions
repetitions <- if (!is.double(repetitions)) {
as.data.frame(sp$species) %>%
nrow() %>%
plyr::round_any(1000, f = ceiling)
} else { repetitions }
# TARGET
# Traduction en nombre de cellules à intégrer dans la réserve finale
target_cell <- if(!is.double(target)) {
mapply(
\(spe, pro) {
m  <- sp_pa[[which(grepl(spe, names(sp)))]]
current <- table(as.data.frame(m))[2] %>% as.numeric()
protect <- ceiling(table(as.data.frame(m))[2]*pro) %>% as.numeric()
paste(
"L'espèce",
sub("_", " ", spe),
"est présente dans",
current,
"unités de conservation."
) %>% print()
paste(
protect, "unités de conservations seront sélectionnées pour conserver",
(pro*100) %>% paste0("%"),
"de cette distribution."
) %>% print()
return(protect)
},
target,
target_prop,
SIMPLIFY  = F,
USE.NAMES = T
)
}
# Abréviation dans le nom du modèle
TGT <- if (!is.double(target)) "YES" else "NO"
# Attribution des bonus/malus aux éléments de conservation
# SPF PARAMETRE 04 ----
# SPF : Species Penalty Factor / CPF : Conservation Penalty Factor
# Coût associé à la rétention d'une unité de gestion dans une réserve
SPF <- ifelse(is.double(spf), spf, "SPE")
# PARAMETRE 05 COST ----
#
spatRast_cost_list100 <- if (is.null(spatRast_cost_list)) NULL else {
Sapply(
spatRast_cost_list[unlist(lapply(spatRast_cost_list, \(x) !is.null(x)))],
\(x) {
# x <- spatRast_cost_list$hotspot
x <- terra::crop(x, e)
x/max(values(x), na.rm = T)*100
})
}
# Abréviation dans le nom du modèle
COST <- if (is.null(spatRast_cost_list)) "NA" else {
names(spatRast_cost_list100) %>%
toupper() %>%
substr(1, 3) %>%
paste(collapse = "+")
}
# Prise en compte du statut des cellules au sein du réseau AMP déjà existant
pa_status <- switch(
status,
`NA` = "none",
IN   = "locked_in",
OUT  = "locked_out"
)
# 3. Génération des fichiers pour Marxan ----
# Génération des fichiers pour faire fonctionner Marxan
# Fichiers d'entrées et de sorties de données pour Marxan
makeMyDir(here("data", "analysis", "marxan"))
marxan_file_names <- sapply(
names(sp_subs),
\(n) {
paste(
n,
paste(
# "PAT", pat,
"REP", repetitions,
"SPF", SPF,
"COS", COST,
"TGT", TGT,
"STT", status,
"ZON", nisl,
sep = "-"
),
sep = "_"
)
}
)
# Préparation du fichier de sortie
fichiers_sorties <- sapply(
marxan_file_names,
\(f) {
# Création du fichier correspondant au run Marxan
path <- here("data", "analysis", "marxan", f)
makeMyDir(path, del = T)
# Création des fichiers données et sorties pour le run
path_inout <- list(
input  = here(path, "input"),
output = here(path, "output")
)
lapply(path_inout, makeMyDir)
# Et pour les figures
path_figures <- here(path, "figures")
makeMyDir(path_figures)
# Copie du logiciel Marxan
file.copy(
from = list.files(
here("scripts", "Marxan"),
pattern = "Marxan_x64$", # Marxan_x64$
full.names = T
),
to   = path
)
# Modification et copie du fichier de paramètres initiaux dans le fichier
# de sortie.
txt <- readLines(here("data", "raw", "input.dat"))
txt[14] <- sub("[0-9]+", repetitions, txt[14])
fileConn <- file(here(path, "input.dat"))
write(x = txt, file = fileConn)
close(fileConn)
return(path)
},
simplify = F,
USE.NAMES = T
)
# Fichiers de sauvegarde
path_inout <- list(
input  = here(path, "input"),
output = here(path, "output")
)
path_figures <- here(path, "figures")
spatRast_data      = dataset
species <- sp_names$ALL
dataset <- sp_subs$ALL
speciesRichness <- sp_sr$ALL
path <- fichiers_sorties$ALL
# Fichiers de sauvegarde
path_inout <- list(
input  = here(path, "input"),
output = here(path, "output")
)
path_figures <- here(path, "figures")
spatRast_data      = dataset
spatRast_cost_list = spatRast_cost_list100
path_inout         = path_inout
path_figures       = path_figures
writePlot = FALSE
writeFile = F
# Pré-traitement
r <- spatRast_data[[1]]
r_proj <- terra::project(r, "EPSG:4087")
r_size <- terra::cellSize(r_proj, unit = "km")
# Statut des cellules uniforme dans notre cas
my_status <- 1
my_costs <- Sapply(
names(spatRast_cost_list100),
\(nsr) {
# nsr <- "hotspot"
# nsr <- "percvar"
# nsr <- "betadiv"
label_legend <- switch(
nsr,
hotspot = "Pourcentage de la \nrichesse spécifique\nmaximale",
percvar = "Pourcentage du\ncoefficient de\nvariation maximal",
betadiv = "Pourcentage de\nla beta-diversité\n maximale"
)
sr <- spatRast_cost_list[[nsr]]
sr_cost <- percentage2Cost(sr)
l <- list(perc = sr, cost = sr_cost)
# Dossier de sortie
path_sc <- here(path_figures, "spatial_cost")
makeMyDir(path_sc)
# polygone de l'île
shp <- maps_marxan[[nisl]]
# Génération des graphiques, sauvegarde des grilles de valeurs
lapply(
names(l),
\(nsrl) {
# nsrl <- "perc"
# nsrl <- "cost"
srl <- l[[nsrl]]
sr_df <- as.data.frame(sr, xy = T)
names(sr_df)[3] <- label_legend
# Nuancier
col_low  <- if (nsrl != "cost") "#150E37FF" else "#FEC085FF"
col_high <- if (nsrl != "cost") "#FEC085FF" else "#150E37FF"
# Label
llegend <- if (nsrl != "cost") names(sr_df)[3] else "Coût"
# Graphique
p_cost <- ggplot() +
geom_tile(data = sr_df, aes(x, y, fill = get(label_legend))) +
scale_fill_gradient(low = col_low, high = col_high) +
guides(fill = guide_colorbar(title = llegend)) +
geom_sf(data = shp, fill = "white", col = NA) +
geom_sf(data = shp, fill = "lightgreen", col = NA, alpha = 0.5) +
scale_x_continuous(expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0)) +
theme(
axis.title           = element_blank(),
panel.background     = element_blank(),
panel.border         = element_blank(),
panel.grid           = element_blank(),
panel.spacing        = unit(0, "lines"),
plot.background      = element_blank()
)
# Sauvegarde
sauv <- if (nsrl != "cost") 100 else "cost"
file_name <- paste(nsr, sauv, sep = "_")
if(writePlot) {
ggexport(
p_cost,
filename = here(path_sc, file_name %>% paste0(".png")),
width = 5000, height = 5000, res = 500
)
}
if(writeFile) {
writeRaster(
srl, here(path_sc, file_name %>% paste0(".tif")), overwrite = T
)
}
}
)
return(as.data.frame(l$cost))
}
)
a <- spatRast_cost_list100 %>% lapply(as.data.frame, xy = T, cells = T)
nn <- which(!(a$hotspot$cell %in% a$percvar$cell))
values(a$hotspot)
values(spatRast_cost_list100$hotspot)
values(spatRast_cost_list100$hotspot) %>% length()
values(spatRast_cost_list100$percvar) %>% length()
values(spatRast_cost_list100$betadiv) %>% length()
?terra::values
values(spatRast_cost_list100$hotspot, na.rm = T) %>% length()
values(spatRast_cost_list100$percvar, na.rm = T) %>% length()
values(spatRast_cost_list100$betadiv, na.rm = T) %>% length()
spatRast_cost_list100
